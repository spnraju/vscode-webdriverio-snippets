{
  "toHaveUrl": {
    "prefix": "wdtoHaveUrl",
    "body": "expect(browser).toHaveUrl(${1:expectedUrl})",
    "description": "Checks if browser is on a specific page"
  },
  "toHaveUrlContaining": {
    "prefix": "wdtoHaveUrlContaining",
    "body": "expect(browser).toHaveUrlContaining(${1:expectedValue})",
    "description": "Checks if browser is on a page URL that contains a value"
  },
  "toHaveTitle": {
    "prefix": "wdtoHaveTitle",
    "body": "expect(browser).toHaveTitle(${1:expectedTitle})",
    "description": "Checks if website has a specific title"
  },
  "toHaveTitleContaining": {
    "prefix": "wdtoHaveTitleContaining",
    "body": "expect(browser).toHaveTitleContaining(${1:expectedValue})",
    "description": "Checks if website has a specific title that contains a value"
  },
  "toBeDisplayed": {
    "prefix": "wdtoBeDisplayed",
    "body": "expect(${1:element}).toBeDisplayed()",
    "description": "Calls isDisplayed on given element"
  },
  "toExist": {
    "prefix": "wdtoExist",
    "body": "expect(${1:element}).toExist()",
    "description": "Calls isExisting on given element"
  },
  "toBePresent": {
    "prefix": "wdtoBePresent",
    "body": "expect(${1:element}).toBePresent()",
    "description": "Same as toExist"
  },
  "toBeExisting": {
    "prefix": "wdtoBeExisting",
    "body": "expect(${1:element}).toBeExisting()",
    "description": "Same as toExist"
  },
  "toBeFocused": {
    "prefix": "wdtoBeFocused",
    "body": "expect(${1:element}).toBeFocused()",
    "description": "Checks if element has focus. This assertion only works in a web context"
  },
  "toHaveAttribute": {
    "prefix": "wdtoHaveAttribute",
    "body": "expect(${1:element}).toHaveAttribute(${2:attribute}, ${3:expectedValue})",
    "description": "Checks if an element has a certain attribute with a specific value"
  },
  "toHaveAttr": {
    "prefix": "wdtoHaveAttr",
    "body": "expect(${1:element}).toHaveAttr(${2:attribute}, ${3:expectedValue})",
    "description": "Same as toHaveAttribute"
  },
  "toHaveAttributeContaining": {
    "prefix": "wdtoHaveAttributeContaining",
    "body": "expect(${1:element}).toHaveAttributeContaining(${2:attribute}, ${3:expectedValue})",
    "description": "Checks if an element has a certain attribute that contains a value"
  },
  "toHaveAttrContaining": {
    "prefix": "wdtoHaveAttrContaining",
    "body": "expect(${1:element}).toHaveAttrContaining(${2:attribute}, ${3:expectedValue})",
    "description": "Same as toHaveAttributeContaining"
  },
  "toHaveElementClass": {
    "prefix": "wdtoHaveElementClass",
    "body": "expect(${1:element}).toHaveElementClass(${2:className}, { message: ${3:textOnError}, })",
    "description": "Checks if an element has a certain class name"
  },
  "toHaveElementClassContaining": {
    "prefix": "wdtoHaveElementClassContaining",
    "body": "expect(${1:element}).toHaveElementClassContaining(${2:expectedValue})",
    "description": "Checks if an element has a certain class name that contains provided value"
  },
  "toHaveElementProperty": {
    "prefix": "wdtoHaveElementProperty",
    "body": "expect(${1:element}).toHaveElementProperty(${2:property}, ${3:expectedValue})",
    "description": "Checks if an element has a certain property"
  },
  "toHaveValue": {
    "prefix": "wdtoHaveValue",
    "body": "expect(${1:element}).toHaveValue(${2:expectedValue}, { ignoreCase: ${3:true} })",
    "description": "Checks if an input element has a certain value"
  },
  "toHaveValueContaining": {
    "prefix": "wdtoHaveValueContaining",
    "body": "expect(${1:element}).toHaveValueContaining(${2:expectedValue})",
    "description": "Checks if an input element contains a certain value"
  },
  "toBeClickable": {
    "prefix": "wdtoBeClickable",
    "body": "expect(${1:element}).toBeClickable()",
    "description": "Checks if an element can be clicked by calling isClickable on the element"
  },
  "toBeDisabled": {
    "prefix": "wdtoBeDisabled",
    "body": "expect(${1:element}).toBeDisabled()",
    "description": "Checks if an element is disabled by calling isEnabled on the element"
  },
  "toBeEnabled": {
    "prefix": "wdtoBeEnabled",
    "body": "expect(${1:element}).toBeEnabled()",
    "description": "Checks if an element is enabled by calling isEnabled on the element"
  },
  "toBeSelected": {
    "prefix": "wdtoBeSelected",
    "body": "expect(${1:element}).toBeSelected()",
    "description": "Checks if an element is enabled by calling isSelected on the element"
  },
  "toBeChecked": {
    "prefix": "wdtoBeChecked",
    "body": "expect(${1:element}).toBeChecked()",
    "description": "Same as toBeSelected"
  },
  "toHaveHref": {
    "prefix": "wdtoHaveHref",
    "body": "expect(${1:element}).toHaveHref(${2:expectedValue})",
    "description": "Checks if link element has a specific link target"
  },
  "toHaveLink": {
    "prefix": "wdtoHaveLink",
    "body": "expect(${1:element}).toHaveLink(${2:expectedValue})",
    "description": "Same as toHaveHref"
  },
  "toHaveHrefContaining": {
    "prefix": "wdtoHaveHrefContaining",
    "body": "expect(${1:element}).toHaveHrefContaining(${2:expectedValue})",
    "description": "Checks if link element contains a specific link target"
  },
  "toHaveLinkContaining": {
    "prefix": "wdtoHaveLinkContaining",
    "body": "expect(${1:element}).toHaveLinkContaining(${2:expectedValue})",
    "description": "Same as toHaveHrefContaining"
  },
  "toHaveId": {
    "prefix": "wdtoHaveId",
    "body": "expect(${1:element}).toHaveId(${2:expectedId})",
    "description": "Checks if element has a specific id attribute"
  },
  "toHaveText": {
    "prefix": "wdtoHaveText",
    "body": "expect(${1:element}).toHaveText(${2:expectedText})",
    "description": "Checks if element has a specific text. Can also be called with an array as parameter in the case where the element can have different texts"
  },
  "toHaveTextContaining": {
    "prefix": "wdtoHaveTextContaining",
    "body": "expect(${1:element}).toHaveTextContaining(${2:expectedText})",
    "description": "Checks if element contains a specific text. Can also be called with an array as parameter in the case where the element can have different texts"
  },
  "toBeDisplayedInViewport": {
    "prefix": "wdtoBeDisplayedInViewport",
    "body": "expect(${1:element}).toBeDisplayedInViewport()",
    "description": "Checks if an element is within the viewport by calling isDisplayedInViewport on the element"
  },
  "toHaveChildren": {
    "prefix": "wdtoHaveChildren",
    "body": "expect(${1:element}).toHaveChildren(${2:optionalExpectedCount})",
    "description": "Checks amount of the fetched element's children by calling element.$('./*') command"
  },
  "toBeElementsArrayOfSize": {
    "prefix": "wdtoBeElementsArrayOfSize",
    "body": "expect(${1:listItems}).toBeElementsArrayOfSize(${2:expectedCount})",
    "description": "Checks amount of fetched elements using $$ command"
  },
  "toBeRequested": {
    "prefix": "wdtoBeRequested",
    "body": "expect(${1:mock}).toBeRequested()",
    "description": "Checks that mock was called"
  },
  "toBeRequestedTimes": {
    "prefix": "wdtoBeRequestedTimes",
    "body": "expect(${1:mock}).toBeRequestedTimes(${2:expectedCount})",
    "description": "Checks that mock was called for the expected amount of times"
  },
  "toBeRequestedWith": {
    "prefix": "wdtoBeRequestedWith",
    "body": "expect(${1:mock}).toBeRequestedWith({ ${2:expectedOptions} })",
    "description": "Checks that mock was called according to the expected options"
  },
  "newSession": {
    "prefix": "wdnewSession",
    "body": "browser.newSession(${1:capabilities})",
    "description": "creates a new WebDriver session with the endpoint node"
  },
  "deleteSession": {
    "prefix": "wddeleteSession",
    "body": "browser.deleteSession()",
    "description": "closes any top-level browsing contexts associated with the current session"
  },
  "status": {
    "prefix": "wdstatus",
    "body": "browser.status()",
    "description": "returns information about whether a remote end is in a state"
  },
  "getTimeouts": {
    "prefix": "wdgetTimeouts",
    "body": "browser.getTimeouts()",
    "description": "Short way to call the findElements command"
  },
  "setTimeouts": {
    "prefix": "wdsetTimeouts",
    "body": "browser.setTimeouts(${1:implicit}, ${2:pageLoad}, ${3:script})",
    "description": "Set Timeouts command sets timeout durations associated with the current session"
  },
  "getUrl": {
    "prefix": "wdgetUrl",
    "body": "browser.getUrl()",
    "description": "returns the URL of the current top-level browsing context"
  },
  "navigateTo": {
    "prefix": "wdnavigateTo",
    "body": "browser.navigateTo(${1:url})",
    "description": "used to cause the user agent to navigate the current top-level browsing context a new location"
  },
  "back": {
    "prefix": "wdback",
    "body": "browser.back()",
    "description": "Back command causes the browser to traverse one step backward"
  },
  "forward": {
    "prefix": "wdforward",
    "body": "browser.forward()",
    "description": "uForward command causes the browser to traverse one step forward"
  },
  "refresh": {
    "prefix": "wdrefresh",
    "body": "browser.refresh()",
    "description": "Refresh command causes the browser to reload the page"
  },
  "getTitle": {
    "prefix": "wdgetTitle",
    "body": "browser.getTitle()",
    "description": "returns the document title of the current top-level browsing context"
  },
  "getWindowHandle": {
    "prefix": "wdgetWindowHandle",
    "body": "browser.getWindowHandle()",
    "description": "returns the window handle for the current top-level browsing context"
  },
  "closeWindow": {
    "prefix": "wdcloseWindow",
    "body": "browser.closeWindow()",
    "description": "closes the current top-level browsing context"
  },
  "switchToWindow": {
    "prefix": "wdswitchToWindow",
    "body": "browser.switchToWindow(${1:handle})",
    "description": "used to select the current top-level browsing context for the current session"
  },
  "createWindow": {
    "prefix": "wdcreateWindow",
    "body": "browser.createWindow(${1:type})",
    "description": "Create a new top-level browsing context"
  },
  "getWindowHandles": {
    "prefix": "wdgetWindowHandles",
    "body": "browser.getWindowHandles()",
    "description": "returns a list of window handles for every open top-level browsing context"
  },
  "printPage": {
    "prefix": "wdprintPage",
    "body": "browser.printPage(${1:optionalOrientation}, ${2:optionalScale}, ${3:optionalBackground}, ${4:optionalWidth}, ${5:optionalHeight}, ${6:optionalTop}, ${7:optionalBottom}, ${8:optionalLeft}, ${9:optionalRight}, ${10:optionalShrinkToFit}, ${11:optionalPageRanges})",
    "description": "renders the document to a paginated PDF document"
  },
  "switchToFrame": {
    "prefix": "wdswitchToFrame",
    "body": "browser.switchToFrame(${1:id})",
    "description": "to select the current top-level browsing context or a child browsing context of the current browsing context"
  },
  "switchToParentFrame": {
    "prefix": "wdswitchToParentFrame",
    "body": "browser.switchToParentFrame()",
    "description": "sets the current browsing context for future commands to the parent of the current browsing context"
  },
  "getWindowRect": {
    "prefix": "wdgetWindowRect",
    "body": "browser.getWindowRect()",
    "description": "returns the size and position on the screen"
  },
  "setWindowRect": {
    "prefix": "wdsetWindowRect",
    "body": "browser.setWindowRect(${1:x}, ${2:y}, ${3:width}, ${4:height})",
    "description": "alters the size and the position of the operating system window"
  },
  "maximizeWindow": {
    "prefix": "wdmaximizeWindow",
    "body": "browser.maximizeWindow()",
    "description": "invokes the window manager-specific 'maximize' operation"
  },
  "minimizeWindow": {
    "prefix": "wdminimizeWindow",
    "body": "browser.minimizeWindow()",
    "description": "invokes the window manager-specific 'minimizeWindow' operation"
  },
  "fullscreenWindow": {
    "prefix": "wdfullscreenWindow",
    "body": "browser.fullscreenWindow()",
    "description": "invokes the window manager-specific 'fullscreenWindow' operation"
  },
  "findElement": {
    "prefix": "wdfindElement",
    "body": "browser.findElement(${1:using}, ${2:value})",
    "description": "to find an element in the current browsing context"
  },
  "findElementFromShadowRoot": {
    "prefix": "wdfindElementFromShadowRoot",
    "body": "browser.findElementFromShadowRoot(${1:shadowId}, ${2:using}, ${3:value})",
    "description": "find an element within the shadow root of an element"
  },
  "findElements": {
    "prefix": "wdfindElements",
    "body": "browser.findElements(${1:using}, ${2:value})",
    "description": "find elements in the current browsing context"
  },
  "findElementsFromShadowRoot": {
    "prefix": "wdfindElementsFromShadowRoot",
    "body": "browser.findElementsFromShadowRoot(${1:shadowId}, ${2:using}, ${3:value})",
    "description": "to find elements within the shadow root of an element"
  },
  "findElementFromElement": {
    "prefix": "wdfindElementFromElement",
    "body": "browser.findElementFromElement(${1:elementId}, ${2:using}, ${3:value})",
    "description": "used to find an element from a web element in the current browsing context"
  },
  "findElementsFromElement": {
    "prefix": "wdfindElementsFromElement",
    "body": "browser.findElementsFromElement(${1:elementId}, ${2:using}, ${3:value})",
    "description": "used to find an elements from a web element in the current browsing context"
  },
  "getElementShadowRoot": {
    "prefix": "wdgetElementShadowRoot",
    "body": "browser.getElementShadowRoot(${1:elementId})",
    "description": "Get the shadow root object of an element"
  },
  "getActiveElement": {
    "prefix": "wdgetActiveElement",
    "body": "browser.getActiveElement()",
    "description": "returns the active element of the current browsing context"
  },
  "isElementSelected": {
    "prefix": "wdisElementSelected",
    "body": "browser.isElementSelected(${1:elementId})",
    "description": "determines if the referenced element is selected or not"
  },
  "isElementDisplayed": {
    "prefix": "wdisElementDisplayed",
    "body": "browser.isElementDisplayed(${1:elementId})",
    "description": "determines the visibility of an element"
  },
  "getElementAttribute": {
    "prefix": "wdgetElementAttribute",
    "body": "browser.getElementAttribute(${1:elementId}, ${2:name})",
    "description": "return the attribute of a web element"
  },
  "getElementProperty": {
    "prefix": "wdgetElementProperty",
    "body": "browser.getElementProperty(${1:elementId}, ${2:name})",
    "description": "return the result of getting a property of an element"
  },
  "getElementCSSValue": {
    "prefix": "wdgetElementCSSValue",
    "body": "browser.getElementCSSValue(${1:elementId}, ${2:propertyName})",
    "description": "retrieves the computed value of the given CSS property"
  },
  "getElementText": {
    "prefix": "wdgetElementText",
    "body": "browser.getElementText(${1:elementId})",
    "description": "return an element’s text 'as rendered'"
  },
  "getElementTagName": {
    "prefix": "wdgetElementTagName",
    "body": "browser.getElementTagName(${1:elementId})",
    "description": "returns the qualified element name of the given web element"
  },
  "getElementRect": {
    "prefix": "wdgetElementRect",
    "body": "browser.getElementRect(${1:elementId})",
    "description": "returns the dimensions and coordinates of the given web element"
  },
  "isElementEnabled": {
    "prefix": "wdisElementEnabled",
    "body": "browser.isElementEnabled(${1:elementId})",
    "description": "determines if the referenced element is enabled or not"
  },
  "elementClick": {
    "prefix": "wdelementClick",
    "body": "browser.elementClick(${1:elementId})",
    "description": "scrolls into view the element if it is not already pointer-interactable, and clicks its in-view center point"
  },
  "elementClear": {
    "prefix": "wdelementClear",
    "body": "browser.elementClear(${1:elementId})",
    "description": "scrolls into view an editable or resettable element and then attempts to clear"
  },
  "elementSendKeys": {
    "prefix": "wdelementSendKeys",
    "body": "browser.elementSendKeys(${1:elementId}, ${2:text}, ${3:value})",
    "description": "scrolls into view the form control element and then sends the provided keys to the element"
  },
  "getPageSource": {
    "prefix": "wdgetPageSource",
    "body": "browser.getPageSource()",
    "description": "returns a string serialization of the DOM of the current browsing context"
  },
  "executeScript": {
    "prefix": "wdexecuteScript",
    "body": "browser.executeScript(${1:script}, ${2:args})",
    "description": "executes a JavaScript function in the context of the current browsing context"
  },
  "executeAsyncScript": {
    "prefix": "wdexecuteAsyncScript",
    "body": "browser.executeAsyncScript(${1:script}, ${2:args})",
    "description": "To execute as an anonymous function"
  },
  "getAllCookies": {
    "prefix": "wdgetAllCookies",
    "body": "browser.getAllCookies()",
    "description": "returns all cookies associated with the address of the current browsing context"
  },
  "addCookie": {
    "prefix": "wdaddCookie",
    "body": "browser.addCookie(${1:cookie})",
    "description": "adds a single cookie to the cookie store associated with the active document"
  },
  "deleteAllCookies": {
    "prefix": "wddeleteAllCookies",
    "body": "browser.deleteAllCookies()",
    "description": "allows deletion of all cookies associated with the active document's address"
  },
  "getNamedCookie": {
    "prefix": "wdgetNamedCookie",
    "body": "browser.getNamedCookie(${1:name})",
    "description": "returns the cookie with the requested name from the associated cookies"
  },
  "deleteCookie": {
    "prefix": "wddeleteCookie",
    "body": "browser.deleteCookie(${1:name})",
    "description": "allows you to delete a single cookie by parameter name"
  },
  "performActions": {
    "prefix": "wdperformActions",
    "body": "browser.performActions(${1:actions})",
    "description": "used to execute complex user actions"
  },
  "releaseActions": {
    "prefix": "wdreleaseActions",
    "body": "browser.releaseActions()",
    "description": "used to release all the keys and pointer buttons that are currently depressed"
  },
  "dismissAlert": {
    "prefix": "wddismissAlert",
    "body": "browser.dismissAlert()",
    "description": "dismisses a simple dialog if present, otherwise error"
  },
  "acceptAlert": {
    "prefix": "wdacceptAlert",
    "body": "browser.acceptAlert()",
    "description": "accepts a simple dialog if present, otherwise error"
  },
  "getAlertText": {
    "prefix": "wdgetAlertText",
    "body": "browser.getAlertText()",
    "description": "returns the message of the current user prompt"
  },
  "sendAlertText": {
    "prefix": "wdsendAlertText",
    "body": "browser.sendAlertText(${1:text})",
    "description": "sets the text field of a window.prompt user prompt to the given value"
  },
  "takeScreenshot": {
    "prefix": "wdtakeScreenshot",
    "body": "browser.takeScreenshot()",
    "description": "takes a screenshot of the top-level browsing context's viewport"
  },
  "takeElementScreenshot": {
    "prefix": "wdtakeElementScreenshot",
    "body": "browser.takeElementScreenshot(${1:elementId}, ${2:scroll})",
    "description": "takes a screenshot of the visible region encompassed by the bounding rectangle of an element"
  },
  "getElementComputedRole": {
    "prefix": "wdgetElementComputedRole",
    "body": "browser.getElementComputedRole(${1:elementId})",
    "description": "Get the computed WAI-ARIA role of an element"
  },
  "getElementComputedLabel": {
    "prefix": "wdgetElementComputedLabel",
    "body": "browser.getElementComputedLabel(${1:elementId})",
    "description": "Get the computed WAI-ARIA role of an element"
  },
  "setPermissions": {
    "prefix": "wdsetPermissions",
    "body": "browser.setPermissions(${1:descriptor}, ${2:state}, ${3:OptionalOneRealm})",
    "description": "Simulates user modification of a PermissionDescriptor's permission state"
  },
  "generateTestReport": {
    "prefix": "wdgenerateTestReport",
    "body": "browser.generateTestReport(${1:message}, ${2:group})",
    "description": "Generates a report for testing. Extension for Reporting API"
  },
  "createMockSensor": {
    "prefix": "wdcreateMockSensor",
    "body": "browser.createMockSensor(${1:mockSensorType}, ${2:maxSamplingFrequency}, ${3:minSamplingFrequency})",
    "description": "Creates a mock sensor to emulate sensors like Ambient Light Sensor"
  },
  "getMockSensor": {
    "prefix": "wdgetMockSensor",
    "body": "browser.getMockSensor(${1:type})",
    "description": "Retrieves information about a given type of mock sensor"
  },
  "updateMockSensor": {
    "prefix": "wdupdateMockSensor",
    "body": "browser.updateMockSensor(${1:type}, ${2:mockSensorType}, ${3:maxSamplingFrequency}, ${4:minSamplingFrequency})",
    "description": "Updates the mock sensor type"
  },
  "deleteMockSensor": {
    "prefix": "wddeleteMockSensor",
    "body": "browser.deleteMockSensor(${1:type})",
    "description": "Delete Session command closes any top-level browsing contexts"
  },
  "setTimeZone": {
    "prefix": "wdsetTimeZone",
    "body": "browser.setTimeZone(${1:time_zone})",
    "description": "Simulates the changing of a time zone for the purposes of testing"
  },
  "addVirtualAuthenticator": {
    "prefix": "wdaddVirtualAuthenticator",
    "body": "browser.addVirtualAuthenticator(${1:optionalProtocol}, ${2:optionalTransport}, ${3:optionalHasResidentKey}, ${4:optionalHasUserVerification}, ${5:optionalIsUserConsenting}, ${6:optionalIsUserVerified}, ${7:optionalExtensions}, ${8:optionalUvm)",
    "description": "Creates a software Virtual Authenticator"
  },
  "removeVirtualAuthenticator": {
    "prefix": "wdremoveVirtualAuthenticator",
    "body": "browser.removeVirtualAuthenticator(${1:authenticatorId})",
    "description": "Removes a previously created Virtual Authenticator"
  },
  "addCredential": {
    "prefix": "wdaddCredential",
    "body": "browser.addCredential(${1:credentialId}, ${2:isResidentCredential}, ${3:rpId}, ${4:privateKey}, ${5:userHandle}, ${6:signCount}, ${7:largeBlob})",
    "description": "Injects a Public Key Credential Source into an existing Virtual Authenticator"
  },
  "getCredentials": {
    "prefix": "wdgetCredentials",
    "body": "browser.getCredentials(${1:authenticatorId})",
    "description": "Returns one Credential Parameters object for every Public Key Credential Source stored in a Virtual Authenticator"
  },
  "removeAllCredentials": {
    "prefix": "wdremoveAllCredentials",
    "body": "browser.removeAllCredentials(${1:authenticatorId})",
    "description": "Removes all Public Key Credential Sources stored on a Virtual Authenticator"
  },
  "removeCredential": {
    "prefix": "wdremoveCredential",
    "body": "browser.removeCredential(${1:authenticatorId}, ${2:credentialId})",
    "description": "Removes a Public Key Credential Source stored on a Virtual Authenticator"
  },
  "setUserVerified": {
    "prefix": "wdsetUserVerified",
    "body": "browser.setUserVerified(${1:authenticatorId}, ${2:credentialId})",
    "description": "sets the isUserVerified property on the Virtual Authenticator"
  },
  "$$": {
    "prefix": "wd$$",
    "body": "browser.$$(${1:selector})",
    "description": "Short way to call the findElements command"
  },
  "$": {
    "prefix": "wd$",
    "body": "browser.$(${1:selector})",
    "description": "Short way to call the findElement command"
  },
  "call": {
    "prefix": "wdcall",
    "body": "browser.call(${1:callback})",
    "description": "Short way to call the findElement command"
  },
  "custom$$": {
    "prefix": "wdcustom$$",
    "body": "browser.custom$$(${1:strategyName}, ${2:strategyArguments})",
    "description": "Allows you to use a custom strategy declared by using browser.addLocatorStrategy"
  },
  "custom$": {
    "prefix": "wdcustom$",
    "body": "browser.custom$(${1:strategyName}, ${2:strategyArguments})",
    "description": "Allows you to use a custom strategy declared by using browser.addLocatorStrategy"
  },
  "debug": {
    "prefix": "wddebug",
    "body": "browser.debug()",
    "description": "Helps you to debug your integration tests"
  },
  "deleteCookies": {
    "prefix": "wddeleteCookies",
    "body": "browser.deleteCookies(${1:names})",
    "description": "Delete cookies visible to the current page"
  },
  "execute": {
    "prefix": "wdexecute",
    "body": "browser.execute(${1:script}, ${2:arguments})",
    "description": "Inject a snippet of JavaScript into the page for execution (synchronous) in the context of the currently selected frame"
  },
  "executeAsync": {
    "prefix": "wdexecuteAsync",
    "body": "browser.executeAsync(${1:script}, ${2:arguments})",
    "description": "Inject a snippet of JavaScript into the page for execution (asynchronous) in the context of the currently selected frame"
  },
  "getCookies": {
    "prefix": "wdgetCookies",
    "body": "browser.getCookies(${1:names})",
    "description": "Retrieve a cookie visible to the current page"
  },
  "getWindowSize": {
    "prefix": "wdgetWindowSize",
    "body": "browser.getWindowSize()",
    "description": "Returns browser window size"
  },
  "keys": {
    "prefix": "wdkeys",
    "body": "browser.keys(${1:value})",
    "description": "Send a sequence of key strokes to the active element"
  },
  "newWindow": {
    "prefix": "wdnewWindow",
    "body": "browser.newWindow(${1:url}, ${2:windowName}, ${3:windowFeatures})",
    "description": "Open new window in browser."
  },
  "pause": {
    "prefix": "wdpause",
    "body": "browser.pause(${1:milliseconds})",
    "description": "Pauses execution for a specific amount of time"
  },
  "react$$": {
    "prefix": "wdreact$$",
    "body": "browser.react$$(${1:selector}, ${2:props}, ${3:state})",
    "description": "Command is a useful command to query multiple React Components by their actual name"
  },
  "react$": {
    "prefix": "wdreact$",
    "body": "browser.react$$(${1:selector}, ${2:props}, ${3:state})",
    "description": "Command is a useful command to query React Components by their actual name"
  },
  "reloadSession": {
    "prefix": "wdreloadSession",
    "body": "browser.reloadSession()",
    "description": "Creates a new Selenium session with your current capabilities"
  },
  "saveRecordingScreen": {
    "prefix": "wdsaveRecordingScreen",
    "body": "browser.saveRecordingScreen(${1:filepath})",
    "description": "**Appium only. Save a video started by startRecordingScreen command to file."
  },
  "saveScreenshot": {
    "prefix": "wdsaveScreenshot",
    "body": "browser.saveScreenshot(${1:filepath})",
    "description": "Save a screenshot of the current browsing context to a PNG file on your OS."
  },
  "setCookies": {
    "prefix": "wdsetCookies",
    "body": "browser.setCookies(${1:cookie})",
    "description": "Sets one or more cookies for the current page"
  },
  "setTimeout": {
    "prefix": "wdsetTimeout",
    "body": "browser.setTimeout(${1:timeouts}, ${2:timeouts.implicit}, ${3:timeouts.pageLoad}, ${4:timeouts.script})",
    "description": "Sets the timeouts associated with the current session"
  },
  "setWindowSize": {
    "prefix": "wdsetWindowSize",
    "body": "browser.setWindowSize(${1:width}, ${2:height})",
    "description": "Resizes browser window outer size according to provided width and height."
  },
  "switchWindow": {
    "prefix": "wdswitchWindow",
    "body": "browser.switchWindow(${1:urlOrTitleToMatch})",
    "description": "Switch focus to a particular tab / window."
  },
  "touchAction": {
    "prefix": "wdtouchAction",
    "body": "browser.touchAction(${1:action})",
    "description": "Touch Action API provides the basis of all gestures that can be automated in Appium"
  },
  "uploadFile": {
    "prefix": "wduploadFile",
    "body": "browser.uploadFile(${1:localPath})",
    "description": "Uploads a file to the Selenium Standalone server or other browser driver"
  },
  "url": {
    "prefix": "wdurl",
    "body": "browser.url(${1:url})",
    "description": "Protocol binding to load the URL of the browser."
  },
  "waitUntil": {
    "prefix": "wdwaitUntil",
    "body": "browser.waitUntil(${1:condition}, ${2:timeout}, ${3:timeoutMsg}, ${4:interval})",
    "description": "This wait command is your universal weapon if you want to wait on something"
  },
  "element$$": {
    "prefix": "wdelement$$",
    "body": "$$(${1:selector})",
    "description": "When calling it from an element scope, the driver will look within the children of that element"
  },
  "element$": {
    "prefix": "wdelement$",
    "body": "$(${1:selector})",
    "description": "When calling it from an element scope, the driver will look within the children of that element"
  },
  "addValue": {
    "prefix": "wdaddValue",
    "body": "addValue(${1:value})",
    "description": "Add a value to an object found by given selector"
  },
  "clearValue": {
    "prefix": "wdclearValue",
    "body": "clearValue()",
    "description": "Clear a <textarea> or text <input> element’s value"
  },
  "click": {
    "prefix": "wdclick",
    "body": "click(${1:options}, ${2:options.button}, ${3:options.x}, ${4:options.y})",
    "description": "Click on an element."
  },
  "elementcustom$$": {
    "prefix": "wdelementcustom$$",
    "body": "custom$$(${1:strategyName}, ${2:strategyArguments})",
    "description": "allows you to use a custom strategy declared by using browser.addLocatorStrategy"
  },
  "elementcustom$": {
    "prefix": "wdelementcustom$",
    "body": "custom$(${1:strategyName}, ${2:strategyArguments})",
    "description": "allows you to use a custom strategy declared by using browser.addLocatorStrategy"
  },
  "doubleClick": {
    "prefix": "wddoubleClick",
    "body": "doubleClick()",
    "description": "Double-click on an element"
  },
  "dragAndDrop": {
    "prefix": "wddragAndDrop",
    "body": "dragAndDrop(${1:target}, ${2:duration})",
    "description": "Drag an item to a destination element."
  },
  "getAttribute": {
    "prefix": "wdgetAttribute",
    "body": "getAttribute(${1:attributeName})",
    "description": "Get an attribute from a DOM-element based on the attribute name."
  },
  "getCSSProperty": {
    "prefix": "wdgetCSSProperty",
    "body": "getCSSProperty(${1:cssProperty})",
    "description": "Get a css property from a DOM-element selected by given selector"
  },
  "getHTML": {
    "prefix": "wdgetHTML",
    "body": "getHTML(${1:includeSelectorTag})",
    "description": "Get source code of specified DOM element by selector."
  },
  "getLocation": {
    "prefix": "wdgetLocation",
    "body": "getLocation(${1:prop})",
    "description": "Determine an element’s location on the page."
  },
  "getProperty": {
    "prefix": "wdgetProperty",
    "body": "getProperty(${1:property})",
    "description": "The Get Element Property command will return the result of getting a property of an element."
  },
  "getSize": {
    "prefix": "wdgetSize",
    "body": "getSize(${1:prop})",
    "description": "Get the width and height for an DOM-element."
  },
  "getTagName": {
    "prefix": "wdgetTagName",
    "body": "getTagName()",
    "description": "Get tag name of a DOM-element."
  },
  "getText": {
    "prefix": "wdgetText",
    "body": "getText()",
    "description": "Get the text content from a DOM-element."
  },
  "getValue": {
    "prefix": "wdgetValue",
    "body": "getValue()",
    "description": "Get the value of a <textarea>, <select> or text <input> found by given selector."
  },
  "isClickable": {
    "prefix": "wdisClickable",
    "body": "isClickable()",
    "description": "Return true if the selected DOM-element exists, is visible, is within viewport, is not disabled"
  },
  "isDisplayed": {
    "prefix": "wdisDisplayed",
    "body": "isDisplayed()",
    "description": "Return true if the selected DOM-element is displayed."
  },
  "isDisplayedInViewport": {
    "prefix": "wdisDisplayedInViewport",
    "body": "isDisplayedInViewport()",
    "description": "Return true if the selected DOM-element found by given selector is partially visible and within the viewport."
  },
  "isEnabled": {
    "prefix": "wdisEnabled",
    "body": "isEnabled()",
    "description": "Return true or false if the selected DOM-element is enabled."
  },
  "isExisting": {
    "prefix": "wdisExisting",
    "body": "isExisting()",
    "description": "Returns true if element exists in the DOM"
  },
  "isFocused": {
    "prefix": "wdisFocused",
    "body": "isFocused()",
    "description": "Return true or false if the selected DOM-element currently has focus."
  },
  "isSelected": {
    "prefix": "wdisSelected",
    "body": "isSelected()",
    "description": "Will return true or false whether or not an <option> or <input> element of type checkbox or radio is currently selected."
  },
  "moveTo": {
    "prefix": "wdmoveTo",
    "body": "moveTo(${1:xoffset}, ${2:yoffset})",
    "description": "Move the mouse by an offset of the specified element."
  },
  "elementReact$$": {
    "prefix": "wdelementreact$$",
    "body": "react$$(${1:selector}, ${2:props}, ${3:state})",
    "description": "Command is a useful command to query multiple React Components by their actual name "
  },
  "elementReact$": {
    "prefix": "wdelementreact$",
    "body": "react$(${1:selector}, ${2:props}, ${3:state})",
    "description": "Command is a useful command to query multiple React Components by their actual name "
  },
  "elementSaveScreenshot": {
    "prefix": "wdelementsaveScreenshot",
    "body": "saveScreenshot(${1:filename})",
    "description": "Save a screenshot of an element to a PNG file on your OS."
  },
  "scrollIntoView": {
    "prefix": "wdscrollIntoView",
    "body": "scrollIntoView(${1:scrollIntoViewOptions})",
    "description": "Scroll element into viewport."
  },
  "selectByAttribute": {
    "prefix": "wdselectByAttribute",
    "body": "selectByAttribute(${1:attribute}, ${2:value})",
    "description": "Select option with a specific value."
  },
  "selectByIndex": {
    "prefix": "wdselectByIndex",
    "body": "selectByIndex(${1:index})",
    "description": "Select option with a specific index."
  },
  "selectByVisibleText": {
    "prefix": "wdselectByVisibleText",
    "body": "selectByVisibleText(${1:text})",
    "description": "Select option with displayed text matching the argument."
  },
  "setValue": {
    "prefix": "wdsetValue",
    "body": "setValue(${1:value})",
    "description": "Send a sequence of key strokes to an element (clears value before)"
  },
  "shadow$$": {
    "prefix": "wdshadow$$",
    "body": "shadow$$(${1:selector})",
    "description": "Access elements inside a given element's shadowRoot"
  },
  "shadow$": {
    "prefix": "wdshadow$",
    "body": "shadow$(${1:selector})",
    "description": "Access element inside a given element's shadowRoot"
  },
  "elementTouchAction": {
    "prefix": "wdelementtouchAction",
    "body": "touchAction(${1:action})",
    "description": "The Touch Action API provides the basis of all gestures that can be automated in Appium"
  },
  "waitForClickable": {
    "prefix": "wdwaitForClickable",
    "body": "waitForClickable(${1:options}, ${2:options.timeout}, ${3:options.reverse}, ${4:options.timeoutMsg}, ${5:options.interval})",
    "description": "Wait for an element for the provided amount of milliseconds to be clickable or not clickable."
  },
  "waitForDisplayed": {
    "prefix": "wdwaitForDisplayed",
    "body": "waitForDisplayed(${1:ms}, ${2:reverse}, ${3:error})",
    "description": "Wait for an element for the provided amount of milliseconds to be displayed or not displayed."
  },
  "waitForEnabled": {
    "prefix": "wdwaitForEnabled",
    "body": "waitForEnabled(${1:ms}, ${2:reverse}, ${3:error})",
    "description": "Wait for an element (selected by css selector) for the provided amount of milliseconds to be (dis/en)abled."
  },
  "waitForExist": {
    "prefix": "wdwaitForExist",
    "body": "waitForExist(${1:ms}, ${2:reverse}, ${3:error})",
    "description": "WWait for an element for the provided amount of milliseconds to be present within the DOM."
  }
}